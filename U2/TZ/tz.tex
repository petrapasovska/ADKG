\documentclass[a4paper, 12pt]{article}
\usepackage[total={17cm,25cm}, top=2.5cm, left=2.5cm, right=2.5cm,  includefoot]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{gensymb}
\usepackage{graphicx}
\graphicspath{ {} }
\usepackage[czech]{babel}
\usepackage{enumitem}
\usepackage{pdfpages}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{amssymb}


\pagestyle{empty} % vypne číslování stránek




\usepackage[OT2,OT1]{fontenc}
\newcommand\cyr
{
\renewcommand\rmdefault{wncyr}
\renewcommand\sfdefault{wncyss}
\renewcommand\encodingdefault{OT2}
\normalfont
\selectfont
}
\DeclareTextFontCommand{\textcyr}{\cyr}
\def\cprime{\char"7E }
\def\cdprime{\char"7F }
\def\eoborotnoye{\char’013}
\def\Eoborotnoye{\char’003}


\begin{document}



\begin{titlepage}
\begin{center}
\noindent
\Large \textbf{České vysoké učení technické v Praze }\\ Fakulta stavební
\vspace{5cm}

\huge

%vložení loga cvut
\begin{figure}[h!]
	\centering
	\includegraphics[width=7cm]{logo.png}
\end{figure}

\vspace{0.5cm}

Algoritmy v digitální kartografii \\

\vspace{3cm}

\Huge  
Konvexní obálky\\

\vspace{2cm}

\Large
Bc. Petra Pasovská \\
Bc. David Zahradník \\

\end{center}

\end{titlepage}




\pagestyle{plain}     % zapne obyčejné číslování
\setcounter{page}{1}  % nastaví čítač stránek znovu od jedné

\tableofcontents
\newpage

\section{Zadání}
Níže uvedené zadání je kopie ze stránek předmětu. 

\begin{figure}[h!]
	\centering
	\includegraphics[clip, trim=0cm 10cm 0cm 3cm, width=1.2\textwidth]{zadani.pdf}
\end{figure}

\subsection{Údaje o bonusových úlohách}



\clearpage

\section{Popis a rozbor problému}
Hlavním cílem této úlohy je tvorba aplikace, která pro vygenerované množství bodů vytvoří konvexní obálku za pomoci různých algoritmů. Pro jednotlivé metody byla zapisována i doba trvání algoritmu. Výsledné časy jsou v závěru následně porovnány.\\
\\
Lze říci, že konvexní obálka množiny M je nejmenší konvexní množina, která množinu M obsahuje. V současné době mají konvexní obálky, v některých literaturách označovány jako konvexní obaly, mnoho využití. Často se využívají jako první odhad tvaru nějakého prostorového jevu, např. detekce kolizí, detekce natočení budov a jejich tvaru v kartografii, analýza shluků atd. [Zdroj: 1]
\\

\begin{figure}[h!]
	\centering
	\includegraphics[width=9cm]{convex_hull.jpg}
	\caption{Ukázka vstupních bodů, kolem nichž je vytvořena konvexní obálka. [zdroj: 2]}
\end{figure}

Konvexní obálky využívá celá řada vědních oborů. Zajímavé bylo využití konvexních obálek v paleontologii, kde za pomoci konvexních obálek jsou vědci schopni určit přibližně tvar těla vyhynulých živočichů, jejichž kosti byly nalezeny. \\

\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{paleontology.jpg}
	\caption{Využití konvexních obálek v paleontologii [zdroj: 3]}
\end{figure}


\section{Popis použitých algoritmů}
Existuje několik způsobů jak vytvořit konvexní obálku. V této úloze byly použity pro tovrbu 3 metody. ( 4 když se povede bonus????)

\subsection{Jarvis Scan}
Tato metoda bývá přirovnávána ke způsobu balení dárků (alternativní název Gift Wrapping Algorithm). Předpokladem pro algoritmus Jarvis Scan je, že 3 body nesmí ležet na jedné přímce. Metoda je poměrně snadná pro zápis, velkou nevýhodou je však časová náročnost O($n^2$), které lze dosáhnout, pokud body z množiny S leží na kružnici. Běžný čas výpočtu bývá O(n*h), kde n je počet vstupních bodů a h je počet bodů, které tvoří obálku. [zdroj: 1]\\
\\
Metoda je pojmenována po R. A. Jarvisu, který ji publikoval v roce 1973. \\
\\
Abychom byli schopni algoritmus sestavit, je potřeba nalézt pivot, označme jej q. Nalezení pivota má časovou náročnost O(n). Pivota nalezneme jako bod s minimální hodnotou souřadnice Y. Následně porovnáváme úhel, který svírá pivot a bod následující a předcházející pivotu, dokud nenalezneme maximální úhel. Když takovýto úhel nalezeneme, je přidán mezi body konvexní obálky. V algoritmu dojde k přeindexování bodů a jsou porovnávány následující body, dokud nově vložený bod není pivot. 

\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{jarvis.jpg}
	\caption{Princip Jarvis Scan algoritmu [zdroj: 4]}
\end{figure}

\subsubsection{Problematické situace}
K chybě v algoritmu může dojít v případě, že tři body budou kolineární. Tedy v případě, že se budou tři body nacházet na jedné přímce. (Jak bychom toto vyřešili hmm??)


\subsubsection{Implementace metody}
\begin{enumerate}
\item Nalezení pivota q:  $ q = min(y_i) $ 
\item Přidej bod q do konvexní obálky:  $ q \rightarrow H  $ 
\item Inicializuj: $p_j = q; p_{j+1} = p_{j-1}$
\item Opakuj, dokud: $ p_{j+1} \ne q $
\subitem Nalezni $p_{j+1}$: $ p_{j+1} = arg  max_{\forall p_i \in P}  \angle (p_{j-1}, p_j, p_i)$
\subitem Přidej $p_{j+1}$: $ p_{j+1} \rightarrow H  $
\subitem Přeindexování bodů: $ p_{j-1} = p_j; p_j = p_{j+1}  $
\end{enumerate}

\subsection{Quick Hull}
Metoda Quick Hull slouží k vytvoření konvexní obálky nad konečným počtem bodů. Využívá techniku "Rozděl a panuj", označovanou anglicky "Divide and Conquer". V této metodě lze najít analogii s QuickSortem, odkud také pochází označení algoritmu. Jedná se o poměrně rychlý algoritmus, časová náročnost je O(n*log(n)), v nejhorším případě je však časová náročnost kvadratická O($n^2$). \\

Pro výpočet metodou Quick Hull je nejprve zapotřebí nalézt extrémní body, v aplikaci byly souřadnice setříděny podle x-ové souřadnice. Bod s nejnižší a nejvyšší hodnotou x-ové souřadnice je vložen do množiny, do které uchováváme body konvexní obálky. Těmito body je vedena pomyslná přímka, která množinu bodů rozdělí na dvě množiny - horní a dolní. V každé polorovině nalezneme nejvzdálenější bod od přímky, tento bod přidáme do množiny bodů patřících do konvexní obálky a vytvoříme přímky tohoto bodu a krajních bodů předešlé přímky. Následně pokračujeme analogicky a nad každou nově vzniklou přímkou nalezneme nejvzdálenější bod.

\begin{figure}[h!]
	\centering
	\includegraphics[width=10cm]{quickhull.jpg}
	\caption{Princip Quick Hull algoritmu [zdroj: 5]}
\end{figure}

\subsubsection{Implementace globální metody}
\begin{enumerate}
\item Vytvoření množiny konvexní obálky, horní a dolní množiny:  $H = 0; S_U = 0; S_L = 0 $ 
\item Nalezení extrémních hodnot:  $ q_1 =  min_{\forall p_i \in S}(x_i); q_3 =  max_{\forall p_i \in S}(x_i) $ 
\item Přidání extrémních bodů do horní a dolní množiny: $S_U \leftarrow q_1; S_U \leftarrow q_3; S_L \leftarrow q_1; S_L \leftarrow q_3 $
\item Pro všechny body množiny: $\forall p_i \in S  $
\subitem Rozhodnutí, zda bod patří do horní množiny: $ if(p_i \in \sigma_l(q_1, q_3)) S_U \leftarrow p_i  $
\subitem V opačném případě: $ S_L \leftarrow p_i  $
\item Přidání krajního bodu do konvexní obálky: $H \leftarrow q_3$
\item Nalezení nejvzdálenějšího bodu $c$ v horní části od přímky, přidání do množiny konvexní obálky a opakování vůči nově vzniklé přímce.
\item Přidání krajního bodu do konvexní obálky: $H \leftarrow q_1$
\item Opakování hledání nejvzdálenějšího bodu v dolní části.
\end{enumerate}

Tady nevím, jestli nerozepsat i implementaci lokální metody??? Možná by to pak bylo pochopitelnější

\section{Vstupní data}


\section{Výstupní data}


\section{Aplikace}



\section{Dokumentace}
\subsection{Třídy}
\subsubsection{Algorithms}
Třída Algorithms obsahuje celkem xx metod. Metody jsou určeny pro výpočty použitých algoritmů.
\\

\textbf{double length2Points(QPoint q, QPoint p)}\\
Metoda jejíž návratová hodnota je typu double vrací velikost spojnice mezi dvěma body.\\

\textbf{void polygonTransform(QPoint p, QPoint k, QPoint p1, QPoint k1, QPolygon &pol)}\\
Metoda je přetížená pro  podobnostní transformaci QPolygon a QLine. Transformační klíč je dán dvěma body se souřadnicemi v obou souřadných soustavách. Body p a k jsou v souřadné soustavě, ze které pochází pol. Body p1 a k1 jsou v souřadné soustavě, do které chceme transformovat. Výsledek transformace přeuloží do proměnné pol.\\

\textbf{rotateByAngle(QPolygon &points, double angle)}\\
Metoda je přetížená pro rotaci QPolygon a QLine. Prvky proměnné pol se pouze rotují podle úhlu angle. Proměnná úhel je v radiánech. Výsledek transformace přeuloží do proměnné pol.
\\

\textbf{TPosition getPointLinePosition(QPoint &q, QPoint &a, QPoint &b)}\\

\\

\textbf{double get2LinesAngle(QPoint &p1,QPoint &p2,QPoint &p3, QPoint &p4)}\\

\\

\textbf{QPolygon CHJarvis (vector<QPoint> &points)}\\
Metoda pro výpočet konvexní obálky nad vektorem bodů metodou Jarvis Scan. Metoda vrácí konvexní obálku s typem QPolygon.
\\

\textbf{QPolygon QHull (vector<QPoint> &points)}\\
Metoda pro výpočet konvexní obálky nad vektorem bodů metodou Quick Hull. Metoda vrácí konvexní obálku s typem QPolygon.
\\

\textbf{void qh (int s, int e, vector<QPoint> &p, QPolygon &h)}\\
Pomocná metoda pro rekurzi v metodě Qhull. Na vstupu jsou indexi bodů s a e, které určují přímku, podle níž se určí zda bod p patří do konvexní obálky h a nebo ne. Metoda nic nevrací, pouze ukládá body, které patří do konvexní obálky.
\\

\textbf{void minimumAreaEnclosingBox (QPolygon &ch, QPolygon &rectangle, QLine &direction)}\\
Metoda pro výpočet hlavních směrů budovy. Na vstupu je konvexní obálka ch a prázdné proměnné rectangle a direction. Do rectangle se uloží minimální ohraničující obdélník a do direction hlavní směr budovy.
\\

\subsubsection{Draw}
Třída Draw obsahuje celkem xx metod. Metody jsou určeny pro generování a vykreslování proměných.
\\

\textbf{void paintEvent(QPaintEvent *e)}\\
Metoda slouží k vykreslení vytvořených, generovaných bodů a zobrazení výsledků použitých algoritmů.
\\

\textbf{void mousePressEvent(QMouseEvent *e)}\\
Po stisknutí levého tlačítka myší na zobrazovací okno, metoda uloží bod se souřadnicemi místa kliknutí.
\\

\textbf{void clearCanvas()}\\
Metoda slouží k vymazání proměnných a k překreslení
\\

\textbf{std::vector<QPoint> generateGrid(int n)}\\
Metoda generuje pravidelnou mřížku. Na vstupu je počet generovaných bodů. Návratová hodnota je vektor bodů.\\

\textbf{std::vector<QPoint> generateRandomPoints(int n)}\\
Metoda generuje náhodné body. Na vstupu je počet generovaných bodů. Návratová hodnota je vektor bodů.\\

\textbf{std::vector<QPoint> generateStarShape(int n)}\\
Metoda generuje body do tvaru hvězdy. Na vstupu je počet generovaných bodů. Návratová hodnota je vektor bodů.\\

\textbf{std::vector<QPoint> generateSquare(int n)}\\
Metoda generuje body do tvaru čtverce. Na vstupu je počet generovaných bodů, změna v počtu bodů se projení s násobkem čtyř. Návratová hodnota je vektor bodů.\\

\textbf{std::vector<QPoint> generateEclipse(int n)}\\
Metoda generuje body do tvaru elipsy. Na vstupu je počet generovaných bodů. Návratová hodnota je vektor bodů.\\

\textbf{std::vector<QPoint> generateCircle(int n)}\\
Metoda generuje body do tvaru kruhu. Na vstupu je počet generovaných bodů. Návratová hodnota je vektor bodů.\\

\textbf{void setCH(QPolygon ch_)}\\
Metoda slouží pro převod konvexní obálky do vykreslovacího okna.\\

\textbf{setRectangle(QPolygon rectangle_)}\\
Metoda slouží pro převod minimální ohraničujícího obdélníku do vykreslovacího okna.\\

\textbf{setDirection(QLine direction_)}\\
Metoda slouží pro převod hlavního směru budovy do vykreslovacího okna.\\

\textbf{setPoints(std::vector<QPoint> points_)}\\
Metoda slouží pro převod vektoru bodů do vykreslovacího okna.\\

\textbf{std::vector<QPoint> getPoints()}\\
Metoda slouží pro převod vektoru bodů z vykreslovacího okna.\\

\textbf{QPolygon getConvexHull()}\\
Metoda slouží pro převod konvexní obálky z vykreslovacího okna.\\

\subsubsection{SortByXAsc}
Třída SortByXAsc slouží k porovnání souřadnic v ose x.
\\

\textbf{bool operator()(QPoint &p1, QPoint &p2)}\\
Přetížený operátor () vrátí bod s větší souřadnicí x z dvojice bodů.
\\

\subsubsection{sortByYAsc}
Třída SortByXAsc slouží k porovnání souřadnic v ose y.
\\

\textbf{bool operator()(QPoint &p1, QPoint &p2)}\\
Přetížený operátor () vrátí bod s větší souřadnicí y z dvojice bodů.
\\

\subsubsection{Widget}
\\

\textbf{void on_pushButton_clicked()}\\
Při stisknutí tlačítka Create CH se volají metody třídy Algorithms dle metody vybrané v comboboxu.
\\

\textbf{void on_generate_clicked()}\\
Při stisknutí tlačítka Generate se volají metody třídy Draw dle metody vybrané v comboboxu.
\\

\void on_pushButton_2_clicked()}\\
Při stisknutí tlačítka Clear se zavolá metoda třídy Draw clearCanvas.
\\

\void on_minimumAreaEnclosingBox_clicked();}\\
Při stisknutí tlačítka MinEndBox se nad konvexní obálkou zavolá metoda třídy Algorithms minimumAreaEnclosingBox.
\\

\clearpage
\section{Závěr}



\clearpage
\section{Reference}

\begin{enumerate}
\item  MARTÍNEK, Petr. Konvexní obálka rozsáhlé množiny bodů v E\^d [online][cit. 31.10.2018]. \\
Dostupné z: http://graphics.zcu.cz/files/86\_BP\_2010\_Martinek\_Petr.pdf  \\

\item Convex Hulls: Explained. [online][cit. 31.10.2018]\\
Dostupné z: https://medium.com/@harshitsikchi/convex-hulls-explained-baab662c4e94\\

\item Convex-hull mass estimates of the dodo (Raphus cucullatus). [online][cit. 31.10.2018]\\
Dostupné z: https://www.semanticscholar.org/paper/Convex-hull-mass-estimates-of-the-dodo-(Raphus-of-a-Brassey-O\'Mahoney/12e07d3b712561cad16501ac8096120e14901eb8

\item GeeksforGeeks: Convex Hull - Set 1 (Jarvis's Algorithm or Wrapping. [online][cit. 5.11.2018]\\
Dostupné z: https://www.geeksforgeeks.org/convex-hull-set-1-jarviss-algorithm-or-wrapping/

\item  BAYER, Tomáš. Geometrické vyhledávání [online][cit. 5.11.2018]. \\
Dostupné z: https://web.natur.cuni.cz/~bayertom/images/courses/Adk/adk4.pdf  \\



\end{enumerate}
\end{document}



 